From ea30d58a2329764b9515bbe671575260c76f8114 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Thu, 25 Aug 2022 10:01:49 -0300
Subject: [PATCH 01/29] core: Conditionally define language encodings

It it defined in an enumeration on dwarf.h, so doing it here as defines
doesn't clash with it and makes this file to build with older distros.

Reported-by: Nathan Chancellor <nathan@kernel.org>
Tested-by: Nathan Chancellor <nathan@kernel.org>
Tested-by: Martin Rodriguez Reboredo <yakoyoku@gmail.com>>
Link: https://lore.kernel.org/lkml/Ywd2zJA63QCkd3RL@kernel.org/
Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarves.c | 112 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 112 insertions(+)

diff --git a/dwarves.c b/dwarves.c
index db1dcf5..394a815 100644
--- a/dwarves.c
+++ b/dwarves.c
@@ -2085,6 +2085,118 @@ int cus__load_file(struct cus *cus, struct conf_load *conf,
 
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))
 
+#ifndef DW_LANG_C89
+#define DW_LANG_C89		0x0001
+#endif
+#ifndef DW_LANG_C
+#define DW_LANG_C		0x0002
+#endif
+#ifndef DW_LANG_Ada83
+#define DW_LANG_Ada83		0x0003
+#endif
+#ifndef DW_LANG_C_plus_plus
+#define DW_LANG_C_plus_plus	0x0004
+#endif
+#ifndef DW_LANG_Cobol74
+#define DW_LANG_Cobol74		0x0005
+#endif
+#ifndef DW_LANG_Cobol85
+#define DW_LANG_Cobol85		0x0006
+#endif
+#ifndef DW_LANG_Fortran77
+#define DW_LANG_Fortran77	0x0007
+#endif
+#ifndef DW_LANG_Fortran90
+#define DW_LANG_Fortran90	0x0008
+#endif
+#ifndef DW_LANG_Pascal83
+#define DW_LANG_Pascal83	0x0009
+#endif
+#ifndef DW_LANG_Modula2
+#define DW_LANG_Modula2		0x000a
+#endif
+#ifndef DW_LANG_Java
+#define DW_LANG_Java		0x000b
+#endif
+#ifndef DW_LANG_C99
+#define DW_LANG_C99		0x000c
+#endif
+#ifndef DW_LANG_Ada95
+#define DW_LANG_Ada95		0x000d
+#endif
+#ifndef DW_LANG_Fortran95
+#define DW_LANG_Fortran95	0x000e
+#endif
+#ifndef DW_LANG_PLI
+#define DW_LANG_PLI		0x000f
+#endif
+#ifndef DW_LANG_ObjC
+#define DW_LANG_ObjC		0x0010
+#endif
+#ifndef DW_LANG_ObjC_plus_plus
+#define DW_LANG_ObjC_plus_plus	0x0011
+#endif
+#ifndef DW_LANG_UPC
+#define DW_LANG_UPC		0x0012
+#endif
+#ifndef DW_LANG_D
+#define DW_LANG_D		0x0013
+#endif
+#ifndef DW_LANG_Python
+#define DW_LANG_Python		0x0014
+#endif
+#ifndef DW_LANG_OpenCL
+#define DW_LANG_OpenCL		0x0015
+#endif
+#ifndef DW_LANG_Go
+#define DW_LANG_Go		0x0016
+#endif
+#ifndef DW_LANG_Modula3
+#define DW_LANG_Modula3		0x0017
+#endif
+#ifndef DW_LANG_Haskell
+#define DW_LANG_Haskell		0x0018
+#endif
+#ifndef DW_LANG_C_plus_plus_03
+#define DW_LANG_C_plus_plus_03	0x0019
+#endif
+#ifndef DW_LANG_C_plus_plus_11
+#define DW_LANG_C_plus_plus_11	0x001a
+#endif
+#ifndef DW_LANG_OCaml
+#define DW_LANG_OCaml		0x001b
+#endif
+#ifndef DW_LANG_Rust
+#define DW_LANG_Rust		0x001c
+#endif
+#ifndef DW_LANG_C11
+#define DW_LANG_C11		0x001d
+#endif
+#ifndef DW_LANG_Swift
+#define DW_LANG_Swift		0x001e
+#endif
+#ifndef DW_LANG_Julia
+#define DW_LANG_Julia		0x001f
+#endif
+#ifndef DW_LANG_Dylan
+#define DW_LANG_Dylan		0x0020
+#endif
+#ifndef DW_LANG_C_plus_plus_14
+#define DW_LANG_C_plus_plus_14	0x0021
+#endif
+#ifndef DW_LANG_Fortran03
+#define DW_LANG_Fortran03	0x0022
+#endif
+#ifndef DW_LANG_Fortran08
+#define DW_LANG_Fortran08	0x0023
+#endif
+#ifndef DW_LANG_RenderScript
+#define DW_LANG_RenderScript	0x0024
+#endif
+#ifndef DW_LANG_BLISS
+#define DW_LANG_BLISS		0x0025
+#endif
+
 int lang__str2int(const char *lang)
 {
 	static const char *languages[] = {
-- 
2.39.1


From 2bb968b567011f8a3e47706dc11c2a6ec442352c Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Fri, 26 Aug 2022 13:18:26 -0300
Subject: [PATCH 02/29] btf: Fix building with system libbpf

Where we may not have newer things, like BTF_KIND_ENUM64.

So we're now again building with -DLIBBPF_EMBEDDED=Off.

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 btf_encoder.c | 27 +++++++++++++++++++++++++--
 btf_loader.c  |  7 +++++++
 dutil.h       |  4 ++++
 3 files changed, 36 insertions(+), 2 deletions(-)

diff --git a/btf_encoder.c b/btf_encoder.c
index daa8e3b..51d9897 100644
--- a/btf_encoder.c
+++ b/btf_encoder.c
@@ -9,12 +9,12 @@
   Copyright (C) Red Hat Inc
  */
 
+#include <linux/btf.h>
 #include "dwarves.h"
 #include "elf_symtab.h"
 #include "btf_encoder.h"
 #include "gobuffer.h"
 
-#include <linux/btf.h>
 #include <bpf/btf.h>
 #include <bpf/libbpf.h>
 #include <ctype.h> /* for isalpha() and isalnum() */
@@ -124,7 +124,7 @@ static int btf_var_secinfo_cmp(const void *a, const void *b)
 #define BITS_ROUNDDOWN_BYTES(bits) ((bits) >> 3)
 #define BITS_ROUNDUP_BYTES(bits) (BITS_ROUNDDOWN_BYTES(bits) + !!BITS_PER_BYTE_MASKED(bits))
 
-static const char * const btf_kind_str[NR_BTF_KINDS] = {
+static const char * const btf_kind_str[] = {
 	[BTF_KIND_UNKN]		= "UNKNOWN",
 	[BTF_KIND_INT]		= "INT",
 	[BTF_KIND_PTR]		= "PTR",
@@ -491,6 +491,29 @@ static int32_t btf_encoder__add_struct(struct btf_encoder *encoder, uint8_t kind
 	return id;
 }
 
+#if LIBBPF_MAJOR_VERSION < 1
+static inline int libbpf_err(int ret)
+{
+        if (ret < 0)
+                errno = -ret;
+        return ret;
+}
+
+static
+int btf__add_enum64(struct btf *btf __maybe_unused, const char *name __maybe_unused,
+		    __u32 byte_sz __maybe_unused, bool is_signed __maybe_unused)
+{
+	return  libbpf_err(-ENOTSUP);
+}
+
+static
+int btf__add_enum64_value(struct btf *btf __maybe_unused, const char *name __maybe_unused,
+			  __u64 value __maybe_unused)
+{
+	return  libbpf_err(-ENOTSUP);
+}
+#endif
+
 static int32_t btf_encoder__add_enum(struct btf_encoder *encoder, const char *name, struct type *etype,
 				     struct conf_load *conf_load)
 {
diff --git a/btf_loader.c b/btf_loader.c
index 406a007..69b63a5 100644
--- a/btf_loader.c
+++ b/btf_loader.c
@@ -312,6 +312,7 @@ out_free:
 	return -ENOMEM;
 }
 
+#if LIBBPF_MAJOR_VERSION >= 1
 static struct enumerator *enumerator__new64(const char *name, uint64_t value)
 {
 	struct enumerator *en = tag__alloc(sizeof(*en));
@@ -354,6 +355,12 @@ out_free:
 	enumeration__delete(enumeration);
 	return -ENOMEM;
 }
+#else
+static int create_new_enumeration64(struct cu *cu __maybe_unused, const struct btf_type *tp __maybe_unused, uint32_t id __maybe_unused)
+{
+	return -ENOTSUP;
+}
+#endif
 
 static int create_new_subroutine_type(struct cu *cu, const struct btf_type *tp, uint32_t id)
 {
diff --git a/dutil.h b/dutil.h
index e45bba0..335a17c 100644
--- a/dutil.h
+++ b/dutil.h
@@ -344,4 +344,8 @@ void __zfree(void **ptr);
 
 #define zfree(ptr) __zfree((void **)(ptr))
 
+#ifndef BTF_KIND_ENUM64
+#define BTF_KIND_ENUM64 19
+#endif
+
 #endif /* _DUTIL_H_ */
-- 
2.39.1


From f5857bd34b220a64eb343a84e21f3c8e11cd9ec7 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Fri, 23 Sep 2022 14:06:31 -0300
Subject: [PATCH 03/29] pahole: Honour --compile when -C is used
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

I.e. generate types recursively from some specified types, now this
works:

⬢[acme@toolbox pahole]$ pahole --compile spinlock
typedef struct {
	int                        counter;              /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
} atomic_t;

typedef unsigned char __u8;
typedef __u8 u8;

typedef short unsigned int __u16;
typedef __u16 u16;

struct qspinlock {
	union {
		atomic_t           val;                  /*     0     4 */
		struct {
			u8         locked;               /*     0     1 */
			u8         pending;              /*     1     1 */
		};                                       /*     0     2 */
		struct {
			u16        locked_pending;       /*     0     2 */
			u16        tail;                 /*     2     2 */
		};                                       /*     0     4 */
	};                                               /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};
typedef struct qspinlock arch_spinlock_t;

struct raw_spinlock {
	arch_spinlock_t            raw_lock;             /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};

struct spinlock {
	union {
		struct raw_spinlock rlock;               /*     0     4 */
	};                                               /*     0     4 */

	/* size: 4, cachelines: 1, members: 1 */
	/* last cacheline: 4 bytes */
};

⬢[acme@toolbox pahole]$

  ------

When not using --compile this ends up calling tag__fprintf() as
formatter is set to class_formatter() that calls tag__fprintf() if
compilable isn't set.

Cc: Adrian Moreno <amorenoz@redhat.com>
Cc: Arnaldo Melo <acme@redhat.com>
Cc: Eelco Chaudron <echaudro@redhat.com>
Cc: Flavio Leitner <fbl@redhat.com>,
Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 pahole.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/pahole.c b/pahole.c
index e87d9a4..9d9bf47 100644
--- a/pahole.c
+++ b/pahole.c
@@ -3217,7 +3217,7 @@ out_btf:
 			 * We don't need to print it for every compile unit
 			 * but the previous options need
 			 */
-			tag__fprintf(class, cu, &conf, stdout);
+			formatter(tag__class(class), cu, class_id);
 			putchar('\n');
 		}
 	}
-- 
2.39.1


From 843fe9bfab4859b4c718b87dccfb27f45833321f Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Fri, 23 Sep 2022 14:40:22 -0300
Subject: [PATCH 04/29] emit: Check if disambiguated struct/enum/union name was
 already emitted in a previous CU

When generating from DWARF we may find the same ambiguous
enum/struct/union name ('struct foo' and 'union foo' on the same .c file), in multiple CUs,
so we need to check again when disambiguating by adding a __N suffix.

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarves_emit.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dwarves_emit.c b/dwarves_emit.c
index 910afb9..304d587 100644
--- a/dwarves_emit.c
+++ b/dwarves_emit.c
@@ -357,6 +357,12 @@ int type__emit_definitions(struct tag *tag, struct cu *cu,
 			} else {
 				// Will be deleted in type__delete() on noticing ctype->suffix_disambiguation != 0
 				tag__namespace(tag)->name = disambiguated_name;
+
+				// Now look again if it was emitted in a previous CU with the disambiguated name
+				if (type_emissions__find_definition(emissions, tag->tag, type__name(ctype)) != NULL) {
+					ctype->definition_emitted = 1;
+					return 0;
+				}
 			}
 
 		}
-- 
2.39.1


From d7507140eab4bf9f1ae3d3721d7803fff9b0c175 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Fri, 23 Sep 2022 17:38:27 -0300
Subject: [PATCH 05/29] emit: Don't mark a enum with nr_members == 0 as
 printed, its just a fwd decl

And with this now we can do a 'pahole --compile' om vmlinux from DWARF
info and it works :-)

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarves_emit.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/dwarves_emit.c b/dwarves_emit.c
index 304d587..7d90d42 100644
--- a/dwarves_emit.c
+++ b/dwarves_emit.c
@@ -121,7 +121,13 @@ static int enumeration__emit_definitions(struct tag *tag,
 
 	enumeration__fprintf(tag, conf, fp);
 	fputs(";\n", fp);
-	type_emissions__add_definition(emissions, etype);
+
+	// See comment on enumeration__fprintf(), it seems this happens with DWARF as well
+	// or BTF doesn't have type->declaration set because DWARF didn't have it set.
+	// But we consider type->nr_members == 0 as just a forward declaration, so don't
+	// mark it as defined because we may need it to __really__ printf it later.
+	if (etype->nr_members != 0)
+		type_emissions__add_definition(emissions, etype);
 	return 1;
 }
 
-- 
2.39.1


From 6fdb0140692acff01a2b53a0a958010b63d67fd6 Mon Sep 17 00:00:00 2001
From: David Lamparter <equinox@diac24.net>
Date: Thu, 7 Jul 2022 10:42:52 +0200
Subject: [PATCH 06/29] dwarves: support DW_TAG_atomic_type

Throwing userspace programs with atomic types at pahole currently
results in either odd results (struct fiels with zero length) or
straight up segfaults (dereferencing a NULL tag).

Add DW_TAG_atomic_type analogous to DW_TAG_volatile_type (which it
behaves identically to.)

Committer notes:

Define DW_TAG_atomic_type to get this to build in older systems.

Signed-off-by: David Lamparter <equinox@diac24.net>
---
 dwarf_loader.c    |  4 +++-
 dwarves.c         |  3 ++-
 dwarves.h         | 13 ++++++++++++-
 dwarves_emit.c    |  1 +
 dwarves_fprintf.c |  3 +++
 5 files changed, 21 insertions(+), 3 deletions(-)

diff --git a/dwarf_loader.c b/dwarf_loader.c
index c2ad2a0..631bbd4 100644
--- a/dwarf_loader.c
+++ b/dwarf_loader.c
@@ -782,7 +782,8 @@ static int tag__recode_dwarf_bitfield(struct tag *tag, struct cu *cu, uint16_t b
 		break;
 
 	case DW_TAG_const_type:
-	case DW_TAG_volatile_type: {
+	case DW_TAG_volatile_type:
+	case DW_TAG_atomic_type: {
 		const struct dwarf_tag *dtag = tag->priv;
 		struct dwarf_tag *dtype = dwarf_cu__find_type_by_ref(cu->priv, &dtag->type);
 
@@ -2002,6 +2003,7 @@ static struct tag *__die__process_tag(Dwarf_Die *die, struct cu *cu,
 	case DW_TAG_restrict_type:
 	case DW_TAG_unspecified_type:
 	case DW_TAG_volatile_type:
+	case DW_TAG_atomic_type:
 		tag = die__create_new_tag(die, cu);		break;
 	case DW_TAG_pointer_type:
 		tag = die__create_new_pointer_tag(die, cu, conf);	break;
diff --git a/dwarves.c b/dwarves.c
index 394a815..9589747 100644
--- a/dwarves.c
+++ b/dwarves.c
@@ -388,7 +388,8 @@ reevaluate:
 		case DW_TAG_const_type:
 		case DW_TAG_typedef:
 		case DW_TAG_rvalue_reference_type:
-		case DW_TAG_volatile_type: {
+		case DW_TAG_volatile_type:
+		case DW_TAG_atomic_type: {
 			struct tag *tag = cu__type(cu, type->type);
 			if (tag == NULL) {
 				tag__id_not_found_fprintf(stderr, type->type);
diff --git a/dwarves.h b/dwarves.h
index bec9f08..d00c828 100644
--- a/dwarves.h
+++ b/dwarves.h
@@ -488,6 +488,11 @@ static inline bool tag__is_volatile(const struct tag *tag)
 	return tag->tag == DW_TAG_volatile_type;
 }
 
+static inline bool tag__is_atomic(const struct tag *tag)
+{
+	return tag->tag == DW_TAG_atomic_type;
+}
+
 static inline bool tag__is_restrict(const struct tag *tag)
 {
 	return tag->tag == DW_TAG_restrict_type;
@@ -497,7 +502,8 @@ static inline int tag__is_modifier(const struct tag *tag)
 {
 	return tag__is_const(tag) ||
 	       tag__is_volatile(tag) ||
-	       tag__is_restrict(tag);
+	       tag__is_restrict(tag) ||
+	       tag__is_atomic(tag);
 }
 
 static inline bool tag__has_namespace(const struct tag *tag)
@@ -540,6 +546,7 @@ static inline int tag__is_tag_type(const struct tag *tag)
 	       tag->tag == DW_TAG_subroutine_type ||
 	       tag->tag == DW_TAG_unspecified_type ||
 	       tag->tag == DW_TAG_volatile_type ||
+	       tag->tag == DW_TAG_atomic_type ||
 	       tag->tag == DW_TAG_LLVM_annotation;
 }
 
@@ -1398,6 +1405,10 @@ extern bool no_bitfield_type_recode;
 
 extern const char tabs[];
 
+#ifndef DW_TAG_atomic_type
+#define DW_TAG_atomic_type 0x47
+#endif
+
 #ifndef DW_TAG_skeleton_unit
 #define DW_TAG_skeleton_unit 0x4a
 #endif
diff --git a/dwarves_emit.c b/dwarves_emit.c
index 7d90d42..0731cec 100644
--- a/dwarves_emit.c
+++ b/dwarves_emit.c
@@ -268,6 +268,7 @@ next_indirection:
 	case DW_TAG_array_type:
 	case DW_TAG_const_type:
 	case DW_TAG_volatile_type:
+	case DW_TAG_atomic_type:
 		type = cu__type(cu, type->type);
 		if (type == NULL)
 			return 0;
diff --git a/dwarves_fprintf.c b/dwarves_fprintf.c
index ce64c79..a3193eb 100644
--- a/dwarves_fprintf.c
+++ b/dwarves_fprintf.c
@@ -93,6 +93,7 @@ static const char *dwarf_tag_names[] = {
 	[DW_TAG_skeleton_unit]		  = "skeleton_unit",
 	[DW_TAG_immutable_type]		  = "immutable_type",
 #endif
+	[DW_TAG_atomic_type]		  = "atomic_type",
 };
 
 static const char *dwarf_gnu_tag_names[] = {
@@ -566,6 +567,7 @@ static const char *__tag__name(const struct tag *tag, const struct cu *cu,
 	case DW_TAG_volatile_type:
 	case DW_TAG_const_type:
 	case DW_TAG_restrict_type:
+	case DW_TAG_atomic_type:
 	case DW_TAG_unspecified_type:
 		type = cu__type(cu, tag->type);
 		if (type == NULL && tag->type != 0)
@@ -580,6 +582,7 @@ static const char *__tag__name(const struct tag *tag, const struct cu *cu,
 			case DW_TAG_volatile_type: prefix = "volatile "; break;
 			case DW_TAG_const_type:    prefix = "const ";	 break;
 			case DW_TAG_restrict_type: suffix = " restrict"; break;
+			case DW_TAG_atomic_type:   prefix = "_Atomic ";  break;
 			}
 			snprintf(bf, len, "%s%s%s ", prefix, type_str, suffix);
 		}
-- 
2.39.1


From b84120772df33f93efeac1206be545311e04cad1 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Tue, 27 Sep 2022 11:39:27 -0300
Subject: [PATCH 07/29] pahole: Allow --compile to work with DWARF in addition
 to with BTF

The recent changes allow for that.

Generating a type in openvswitch and all it needs, recursively, from the
DWARF info for that project, then printing it out from the compileable
pahole output does a full circle and gets us back with the types pahole
generated from DWARF:

  $ pahole -C ovsrec_ssl --compile /usr/lib/debug/.dwz/openvswitch-2.17.0-3.fc36.x86_64 > ovs.c ; echo "static struct ovsrec_ssl foo;" >> ovs.c ; gcc -g -c ovs.c
  $ file ovs.o
  ovs.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), with debug_info, not stripped
  $ pahole ovs.o
  struct hmap_node {
  	size_t                     hash;                 /*     0     8 */
  	struct hmap_node *         next;                 /*     8     8 */

  	/* size: 16, cachelines: 1, members: 2 */
  	/* last cacheline: 16 bytes */
  };
  struct uuid {
  	uint32_t                   parts[4];             /*     0    16 */

  	/* size: 16, cachelines: 1, members: 1 */
  	/* last cacheline: 16 bytes */
  };
  struct ovs_list {
  	struct ovs_list *          prev;                 /*     0     8 */
  	struct ovs_list *          next;                 /*     8     8 */

  	/* size: 16, cachelines: 1, members: 2 */
  	/* last cacheline: 16 bytes */
  };
  struct ovsdb_idl_row {
  	struct hmap_node           hmap_node;            /*     0    16 */
  	struct uuid                uuid;                 /*    16    16 */
  	struct ovs_list            src_arcs;             /*    32    16 */
  	struct ovs_list            dst_arcs;             /*    48    16 */
  	/* --- cacheline 1 boundary (64 bytes) --- */
  	struct ovsdb_idl_table *   table;                /*    64     8 */
  	struct ovsdb_datum *       old_datum;            /*    72     8 */
  	_Bool                      parsed;               /*    80     1 */

  	/* XXX 7 bytes hole, try to pack */

  	struct ovs_list            reparse_node;         /*    88    16 */
  	struct ovsdb_datum *       new_datum;            /*   104     8 */
  	long unsigned int *        prereqs;              /*   112     8 */
  	long unsigned int *        written;              /*   120     8 */
  	/* --- cacheline 2 boundary (128 bytes) --- */
  	struct hmap_node           txn_node;             /*   128    16 */
  	long unsigned int *        map_op_written;       /*   144     8 */
  	struct map_op_list * *     map_op_lists;         /*   152     8 */
  	long unsigned int *        set_op_written;       /*   160     8 */
  	struct set_op_list * *     set_op_lists;         /*   168     8 */
  	unsigned int               change_seqno[3];      /*   176    12 */

  	/* XXX 4 bytes hole, try to pack */

  	/* --- cacheline 3 boundary (192 bytes) --- */
  	struct ovs_list            track_node;           /*   192    16 */
  	long unsigned int *        updated;              /*   208     8 */
  	struct ovsdb_datum *       tracked_old_datum;    /*   216     8 */

  	/* size: 224, cachelines: 4, members: 20 */
  	/* sum members: 213, holes: 2, sum holes: 11 */
  	/* last cacheline: 32 bytes */
  };
  struct hmap {
  	struct hmap_node * *       buckets;              /*     0     8 */
  	struct hmap_node *         one;                  /*     8     8 */
  	size_t                     mask;                 /*    16     8 */
  	size_t                     n;                    /*    24     8 */

  	/* size: 32, cachelines: 1, members: 4 */
  	/* last cacheline: 32 bytes */
  };
  struct smap {
  	struct hmap                map;                  /*     0    32 */

  	/* size: 32, cachelines: 1, members: 1 */
  	/* last cacheline: 32 bytes */
  };
  struct ovsrec_ssl {
  	struct ovsdb_idl_row       header_;              /*     0   224 */
  	/* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
  	_Bool                      bootstrap_ca_cert;    /*   224     1 */

  	/* XXX 7 bytes hole, try to pack */

  	char *                     ca_cert;              /*   232     8 */
  	char *                     certificate;          /*   240     8 */
  	struct smap                external_ids;         /*   248    32 */
  	/* --- cacheline 4 boundary (256 bytes) was 24 bytes ago --- */
  	char *                     private_key;          /*   280     8 */

  	/* size: 288, cachelines: 5, members: 6 */
  	/* sum members: 281, holes: 1, sum holes: 7 */
  	/* last cacheline: 32 bytes */
  };
  $

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 pahole.c | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/pahole.c b/pahole.c
index 9d9bf47..1f844e3 100644
--- a/pahole.c
+++ b/pahole.c
@@ -2999,11 +2999,6 @@ static enum load_steal_kind pahole_stealer(struct cu *cu,
 {
 	int ret = LSK__DELETE;
 
-	if (compilable && strcmp(cu->dfops->name, "btf")) {
-		fprintf(stderr, "pahole: --compile currently only works with BTF.\n");
-		return LSK__STOP_LOADING;
-	}
-
 	if (!cu__filter(cu))
 		goto filter_it;
 
-- 
2.39.1


From f01e5f3a849558b8ed6b310686d10738f4c2f3bf Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Thu, 29 Sep 2022 09:43:16 -0300
Subject: [PATCH 08/29] dwarf_loader: Support DW_TAG_label outside
 DW_TAG_lexblock

This happens with asm CUs, noticed when building the Linux kernel with
clang 15, where we have, for instance:

  Contents of the .debug_info section:

    Compilation Unit @ offset 0x0:
     Length:        0x1df (32-bit)
     Version:       5
     Unit Type:     DW_UT_compile (1)
     Abbrev Offset: 0x0
     Pointer Size:  8
   <0><c>: Abbrev Number: 1 (DW_TAG_compile_unit)
      <d>   DW_AT_stmt_list   : 0x0
      <11>   DW_AT_ranges      : 0xc
      <15>   DW_AT_name        : arch/x86/kernel/verify_cpu.S
      <32>   DW_AT_comp_dir    : /home/nathan/cbl/src/linux
      <4d>   DW_AT_producer    : ClangBuiltLinux clang version 16.0.0 (https://github.com/llvm/llvm-project 7e22179d38c438fedb0d9bb0cff1585843bd7082)
      <c2>   DW_AT_language    : 32769    (MIPS assembler)
   <1><c4>: Abbrev Number: 2 (DW_TAG_label)
      <c5>   DW_AT_name        : startup_64
      <d0>   DW_AT_decl_file   : 0x0
      <d4>   DW_AT_decl_line   : 0x364
      <d8>   DW_AT_low_pc      : 0xffffffff81000000
   <1><e0>: Abbrev Number: 2 (DW_TAG_label)
      <e1>   DW_AT_name        : secondary_startup_64
      <f6>   DW_AT_decl_file   : 0x0
      <fa>   DW_AT_decl_line   : 0x399
      <fe>   DW_AT_low_pc      : 0xffffffff81000060
   <1><106>: Abbrev Number: 2 (DW_TAG_label)
      <107>   DW_AT_name        : secondary_startup_64_no_verify
      <126>   DW_AT_decl_file   : 0x0
      <12a>   DW_AT_decl_line   : 0x39f
      <12e>   DW_AT_low_pc      : 0xffffffff81000065
   <1><136>: Abbrev Number: 2 (DW_TAG_label)
      <137>   DW_AT_name        : verify_cpu
      <142>   DW_AT_decl_file   : 0x0
      <146>   DW_AT_decl_line   : 0x430
      <14a>   DW_AT_low_pc      : 0xffffffff81000150
  <SNIP>

Reported-by: Nathan Chancellor <nathan@kernel.org>
Cc: Nick Desaulniers <ndesaulniers@google.com>
Cc: Yonghong Song <yhs@fb.com>
Link: https://lore.kernel.org/dwarves/YzWSzXKcm6rSWOC5@kernel.org
Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarf_loader.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/dwarf_loader.c b/dwarf_loader.c
index 631bbd4..28a912e 100644
--- a/dwarf_loader.c
+++ b/dwarf_loader.c
@@ -1485,7 +1485,12 @@ static struct tag *die__create_new_label(Dwarf_Die *die,
 	if (label == NULL)
 		return NULL;
 
-	lexblock__add_label(lexblock, label);
+	if (lexblock != NULL) {
+		// asm CUs have labels and they will be in the cu top level tag list
+		// See die__process_unit()
+		lexblock__add_label(lexblock, label);
+	}
+
 	return &label->ip.tag;
 }
 
@@ -2037,6 +2042,12 @@ static struct tag *__die__process_tag(Dwarf_Die *die, struct cu *cu,
 		 */
 		tag = &unsupported_tag;
 		break;
+	case DW_TAG_label:
+		if (conf->ignore_labels)
+			tag = &unsupported_tag; // callers will assume conf->ignore_labels is true
+		else // We can have labels in asm CUs, no lexblock
+			tag = die__create_new_label(die, NULL, cu, conf);
+		break;
 	}
 
 	if (tag != NULL)
@@ -2055,7 +2066,8 @@ static int die__process_unit(Dwarf_Die *die, struct cu *cu, struct conf_load *co
 		if (tag == &unsupported_tag) {
 			// XXX special case DW_TAG_dwarf_procedure, appears when looking at a recent ~/bin/perf
 			// Investigate later how to properly support this...
-			if (dwarf_tag(die) != DW_TAG_dwarf_procedure)
+			if (dwarf_tag(die) != DW_TAG_dwarf_procedure &&
+			    dwarf_tag(die) != DW_TAG_label) // conf->ignore_labels == true, see die__process_tag()
 				tag__print_not_supported(dwarf_tag(die));
 			continue;
 		}
-- 
2.39.1


From e819d737de88dc1fd6d31091c66f826ead40761e Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Fri, 30 Sep 2022 11:40:39 -0300
Subject: [PATCH 09/29] pahole: Add "btf" to the format-path option man page

Was missing, fix it.

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 man-pages/pahole.1 | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/man-pages/pahole.1 b/man-pages/pahole.1
index bb88e2f..d752ccb 100644
--- a/man-pages/pahole.1
+++ b/man-pages/pahole.1
@@ -137,8 +137,8 @@ offset from the beginning of a struct is.
 .TP
 .B \-F, \-\-format_path
 Allows specifying a list of debugging formats to try, in order. Right now this
-includes "ctf" and "dwarf". The default format path used is equivalent to
-"-F dwarf,ctf".
+includes "btf", "ctf" and "dwarf". The default format path used is equivalent to
+"-F dwarf,btf,ctf".
 
 .TP
 .B \-\-hashbits=BITS
-- 
2.39.1


From 79d9a783ea74797aa4304009e0cf1bdb9235fcf4 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Tue, 4 Oct 2022 18:09:33 -0300
Subject: [PATCH 10/29] pahole: Support '--lang/--lang_exclude=asm'
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

It is disjoint from the other languages and then the first simple
implementation of language inclusion/exclusion didn't support it, add
an special case to test against 0x8001 (DW_LANG_Mips_Assembler) to cover
that.

This is needed as recently compilers started to add DWARF constructs to
represent asm CUs that broke pahole as it didn't support
DW_TAG_unspecified_type as a "type", so add it in case in the future we
want to exclude such CUs.

The DW_TAG_unspecified_type tag is going to be supported in the next
csets tho.

We also may want this to exclude new tags that aren't supported in BTF,
etc.

Cc: Martin Liška <mliska@suse.cz>
Cc: Nick Clifton <nickc@redhat.com>
Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarves.c          | 3 +++
 man-pages/pahole.1 | 2 +-
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/dwarves.c b/dwarves.c
index 9589747..0405592 100644
--- a/dwarves.c
+++ b/dwarves.c
@@ -2240,6 +2240,9 @@ int lang__str2int(const char *lang)
 	[DW_LANG_UPC]		 = "upc",
 	};
 
+	if (strcasecmp(lang, "asm") == 0)
+		return DW_LANG_Mips_Assembler;
+
 	// c89 is the first, bliss is the last, see /usr/include/dwarf.h
 	for (int id = DW_LANG_C89; id <= DW_LANG_BLISS; ++id)
 		if (languages[id] && strcasecmp(lang, languages[id]) == 0)
diff --git a/man-pages/pahole.1 b/man-pages/pahole.1
index d752ccb..45a21af 100644
--- a/man-pages/pahole.1
+++ b/man-pages/pahole.1
@@ -378,7 +378,7 @@ Only process compilation units built from source code written in the specified l
 
 Supported languages:
 
-  ada83, ada95, bliss, c, c89, c99, c11, c++, c++03, c++11, c++14, cobol74,
+  ada83, ada95, asm, bliss, c, c89, c99, c11, c++, c++03, c++11, c++14, cobol74,
   cobol85, d, dylan, fortran77, fortran90, fortran95, fortran03, fortran08,
   go, haskell, java, julia, modula2, modula3, objc, objc++, ocaml, opencl,
   pascal83, pli, python, renderscript, rust, swift, upc
-- 
2.39.1


From d5012f7be79f1b81c9f7ac8855c11d3bf3488ea5 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Tue, 4 Oct 2022 18:19:46 -0300
Subject: [PATCH 11/29] btf_encoder: Add extra debug info for unsupported DWARF
 tags

Recently we got a report of DW_TAG_unspecified_type triggering this
warning:

[ 1413s]   BTF     .btf.vmlinux.bin.o
[ 1413s] Unsupported DW_TAG_unspecified_type(0x3b)
[ 1413s] Encountered error while encoding BTF.

Probably tag->type is zero, but would be great to have this offhand, add
that info to the error message.

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 btf_encoder.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/btf_encoder.c b/btf_encoder.c
index 51d9897..7ad3f29 100644
--- a/btf_encoder.c
+++ b/btf_encoder.c
@@ -963,8 +963,8 @@ static int btf_encoder__encode_tag(struct btf_encoder *encoder, struct tag *tag,
 	case DW_TAG_subroutine_type:
 		return btf_encoder__add_func_proto(encoder, tag__ftype(tag), type_id_off);
 	default:
-		fprintf(stderr, "Unsupported DW_TAG_%s(0x%x)\n",
-			dwarf_tag_name(tag->tag), tag->tag);
+		fprintf(stderr, "Unsupported DW_TAG_%s(0x%x): type: 0x%x\n",
+			dwarf_tag_name(tag->tag), tag->tag, ref_type_id);
 		return -1;
 	}
 }
-- 
2.39.1


From cf27a2b805f213561351fe15217717b0b2565f19 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Thu, 6 Oct 2022 17:38:06 -0300
Subject: [PATCH 12/29] core: Print more info on tag__assert_search_result()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Its about showing the tag for which we're not finding its type, so we
want to know if it is a class member, a function argument, etc:

Before:

⬢[acme@toolbox pahole]$ pahole --compile eelco/ovs-vswitchd_rhel8 > a
/var/home/acme/git/pahole/dwarves_emit.c::typedef__emit_definitions(158): tag not found, please report to acme@kernel.org

After:

⬢[acme@toolbox pahole]$ pahole --compile eelco/ovs-vswitchd_rhel8 > a
/var/home/acme/git/pahole/dwarves_emit.c::typedef__emit_definitions(158, related to the type of tag DW_TAG_typedef "_IO_lock_t"): tag not found, please report to acme@kernel.org

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 codiff.c             |  2 +-
 ctracer.c            |  8 ++++----
 dwarves.c            |  6 +++---
 dwarves.h            |  8 ++++----
 dwarves_emit.c       |  2 +-
 dwarves_reorganize.c |  4 ++--
 pahole.c             | 10 +++++-----
 syscse.c             |  2 +-
 8 files changed, 21 insertions(+), 21 deletions(-)

diff --git a/codiff.c b/codiff.c
index 35aee3f..9e5c565 100644
--- a/codiff.c
+++ b/codiff.c
@@ -433,7 +433,7 @@ static void show_changed_member(char change, const struct class_member *member,
 	const struct tag *type = cu__type(cu, member->tag.type);
 	char bf[128];
 
-	tag__assert_search_result(type);
+	tag__assert_search_result(type, member->tag.tag, class_member__name(member));
 	printf("    %c%-26s %-21s /* %5u %5zd */\n",
 	       change, tag__name(type, cu, bf, sizeof(bf), NULL),
 	       class_member__name(member),
diff --git a/ctracer.c b/ctracer.c
index 1345946..8d6eac8 100644
--- a/ctracer.c
+++ b/ctracer.c
@@ -357,7 +357,7 @@ static struct class *class__clone_base_types(const struct tag *tag,
 	type__for_each_data_member_safe(&clone->type, pos, next) {
 		struct tag *member_type = cu__type(cu, pos->tag.type);
 
-		tag__assert_search_result(member_type);
+		tag__assert_search_result(member_type, pos->tag.tag, class_member__name(pos));
 		if (!tag__is_base_type(member_type, cu)) {
 			next = class__remove_member(clone, cu, pos);
 			class_member__delete(pos);
@@ -498,7 +498,7 @@ static struct tag *pointer_filter(struct tag *tag, struct cu *cu,
 	type__for_each_member(type, pos) {
 		struct tag *ctype = cu__type(cu, pos->tag.type);
 
-		tag__assert_search_result(ctype);
+		tag__assert_search_result(ctype, pos->tag.tag, class_member__name(pos));
 		if (tag__is_pointer_to(ctype, target_type_id))
 			return tag;
 	}
@@ -687,7 +687,7 @@ static int function__emit_probes(struct function *func, uint32_t function_id,
 	list_for_each_entry(pos, &func->proto.parms, tag.node) {
 		struct tag *type = cu__type(cu, pos->tag.type);
 
-		tag__assert_search_result(type);
+		tag__assert_search_result(type, pos->tag.tag, parameter__name(pos));
 		if (!tag__is_pointer_to(type, target_type_id))
 			continue;
 
@@ -762,7 +762,7 @@ static int cu_emit_pointer_probes_iterator(struct cu *cu, void *cookie)
 	type__for_each_member(tag__type(pointer), pos_member) {
 		struct tag *ctype = cu__type(cu, pos_member->tag.type);
 
-		tag__assert_search_result(ctype);
+		tag__assert_search_result(ctype, pos_member->tag.tag, class_member__name(pos_member));
 		if (tag__is_pointer_to(ctype, target_type_id))
 			break;
 	}
diff --git a/dwarves.c b/dwarves.c
index 0405592..fbebc1d 100644
--- a/dwarves.c
+++ b/dwarves.c
@@ -175,10 +175,10 @@ void tag__delete(struct tag *tag)
 	}
 }
 
-void tag__not_found_die(const char *file, int line, const char *func)
+void tag__not_found_die(const char *file, int line, const char *func, int tag, const char *name)
 {
-	fprintf(stderr, "%s::%s(%d): tag not found, please report to "
-			"acme@kernel.org\n", file, func, line);
+	fprintf(stderr, "%s::%s(%d, related to the type of tag DW_TAG_%s \"%s\"): tag not found, please report to "
+			"acme@kernel.org\n", file, func, line, dwarf_tag_name(tag), name);
 	exit(1);
 }
 
diff --git a/dwarves.h b/dwarves.h
index d00c828..d1aa240 100644
--- a/dwarves.h
+++ b/dwarves.h
@@ -581,11 +581,11 @@ size_t tag__fprintf(struct tag *tag, const struct cu *cu,
 
 const char *tag__name(const struct tag *tag, const struct cu *cu,
 		      char *bf, size_t len, const struct conf_fprintf *conf);
-void tag__not_found_die(const char *file, int line, const char *func);
+void tag__not_found_die(const char *file, int line, const char *func, int tag, const char *name);
 
-#define tag__assert_search_result(tag) \
-	do { if (!tag) tag__not_found_die(__FILE__,\
-					  __LINE__, __func__); } while (0)
+#define tag__assert_search_result(result, tag, name) \
+	do { if (!result) tag__not_found_die(__FILE__,\
+					  __LINE__, __func__, tag, name); } while (0)
 
 size_t tag__size(const struct tag *tag, const struct cu *cu);
 size_t tag__nr_cachelines(const struct conf_fprintf *conf, const struct tag *tag, const struct cu *cu);
diff --git a/dwarves_emit.c b/dwarves_emit.c
index 0731cec..dec446d 100644
--- a/dwarves_emit.c
+++ b/dwarves_emit.c
@@ -155,7 +155,7 @@ static int typedef__emit_definitions(struct tag *tdef, struct cu *cu,
 	}
 
 	type = cu__type(cu, tdef->type);
-	tag__assert_search_result(type);
+	tag__assert_search_result(type, tdef->tag, type__name(def));
 
 	switch (type->tag) {
 	case DW_TAG_array_type:
diff --git a/dwarves_reorganize.c b/dwarves_reorganize.c
index 79b159b..14f5e82 100644
--- a/dwarves_reorganize.c
+++ b/dwarves_reorganize.c
@@ -550,8 +550,8 @@ static int class__demote_bitfields(struct class *class, const struct cu *cu,
 				cu__find_base_type_of_size(cu, bytes_needed,
 							   &new_type_id);
 
-			tag__assert_search_result(old_type_tag);
-			tag__assert_search_result(new_type_tag);
+			tag__assert_search_result(old_type_tag, member->tag.tag, class_member__name(member));
+			tag__assert_search_result(new_type_tag, member->tag.tag, class_member__name(member));
 
 			if (verbose) {
 				char old_bf[64], new_bf[64];
diff --git a/pahole.c b/pahole.c
index 1f844e3..4636f01 100644
--- a/pahole.c
+++ b/pahole.c
@@ -871,19 +871,19 @@ static void class__resize_LP(struct tag *tag, struct cu *cu)
 		    	continue;
 
 		type = cu__type(cu, tag_pos->type);
-		tag__assert_search_result(type);
+		tag__assert_search_result(type, tag_pos->tag, class_member__name(tag__class_member(tag_pos)));
 		if (type->tag == DW_TAG_array_type) {
 			int i;
 			for (i = 0; i < tag__array_type(type)->dimensions; ++i)
 				array_multiplier *= tag__array_type(type)->nr_entries[i];
 
 			type = cu__type(cu, type->type);
-			tag__assert_search_result(type);
+			tag__assert_search_result(type, tag_pos->tag, class_member__name(tag__class_member(tag_pos)));
 		}
 
 		if (tag__is_typedef(type)) {
 			type = tag__follow_typedef(type, cu);
-			tag__assert_search_result(type);
+			tag__assert_search_result(type, tag_pos->tag, class_member__name(tag__class_member(tag_pos)));
 		}
 
 		switch (type->tag) {
@@ -953,7 +953,7 @@ static void union__find_new_size(struct tag *tag, struct cu *cu)
 		    	continue;
 
 		type = cu__type(cu, tag_pos->type);
-		tag__assert_search_result(type);
+		tag__assert_search_result(type, tag_pos->tag, class_member__name(tag__class_member(tag_pos)));
 		if (tag__is_typedef(type))
 			type = tag__follow_typedef(type, cu);
 
@@ -1096,7 +1096,7 @@ static void print_structs_with_pointer_to(struct cu *cu, uint32_t type)
 		type__for_each_member(&pos->type, pos_member) {
 			struct tag *ctype = cu__type(cu, pos_member->tag.type);
 
-			tag__assert_search_result(ctype);
+			tag__assert_search_result(ctype, pos_member->tag.tag, class_member__name(pos_member));
 			if (!tag__is_pointer_to(ctype, type))
 				continue;
 
diff --git a/syscse.c b/syscse.c
index 67a6c52..4a5b199 100644
--- a/syscse.c
+++ b/syscse.c
@@ -64,7 +64,7 @@ static void emit_wrapper(struct function *f, struct cu *cu)
 		const type_id_t type_id = parm->tag.type;
 		struct tag *type = cu__type(cu, type_id);
 
-		tag__assert_search_result(type);
+		tag__assert_search_result(type, parm->tag.tag, parameter__name(parm));
 		if (type->tag == DW_TAG_base_type) {
 			struct base_type *bt = tag__base_type(type);
 			char bf[64];
-- 
2.39.1


From 56bcfa9135312ffea09ba5e948b81fa76eb76d39 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Fri, 7 Oct 2022 11:56:16 -0300
Subject: [PATCH 13/29] fprintf: Emit "_Atomic" modifiers for
 DW_TAG_atomic_type

  $ pahole -C ovs_barrier eelco/ovs-vswitchd_f35
  struct ovs_barrier {
          struct {
                  _Atomic struct ovs_barrier_impl * p;     /*     0     8 */
          } impl;                                          /*     0     8 */

          /* size: 8, cachelines: 1, members: 1 */
          /* last cacheline: 8 bytes */
  };

  $ pahole -C ovs_barrier_impl eelco/ovs-vswitchd_f35
  struct ovs_barrier_impl {
          uint32_t                   size;                 /*     0     4 */
          atomic_count               count;                /*     4     4 */
          struct seq *               seq;                  /*     8     8 */
          struct ovs_refcount        refcnt;               /*    16     4 */

          /* size: 24, cachelines: 1, members: 4 */
          /* padding: 4 */
          /* last cacheline: 24 bytes */
  };

  $ pahole -EC ovs_barrier_impl eelco/ovs-vswitchd_f35
  struct ovs_barrier_impl {
  	/* typedef uint32_t -> __uint32_t */ unsigned int               size;            /*     0     4 */
  	/* typedef atomic_count */ struct atomic_count {
  		/* typedef atomic_uint */ _Atomic unsigned int count;                    /*     4     4 */
  	} count; /*     4     4 */
  	struct seq *               seq;                                                  /*     8     8 */
  	struct ovs_refcount {
  		/* typedef atomic_uint */ _Atomic unsigned int count;                    /*    16     4 */
  	}refcnt; /*    16     4 */

  	/* size: 24, cachelines: 1, members: 4 */
  	/* padding: 4 */
  	/* last cacheline: 24 bytes */
  };

  $

  And --compile works now with these files:

  $ pahole --compile -C udpif eelco/ovs-vswitchd_f35 > updif.c ; echo "static struct udpif bla;" >> updif.c ; gcc -g -c updif.c ; file updif.o ; pahole -C udpif updif.o
  updif.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), with debug_info, not stripped
  struct udpif {
          struct ovs_list            list_node;            /*     0    16 */
          struct dpif *              dpif;                 /*    16     8 */
          struct dpif_backer *       backer;               /*    24     8 */
          struct handler *           handlers;             /*    32     8 */
          uint32_t                   n_handlers;           /*    40     4 */

          /* XXX 4 bytes hole, try to pack */

          struct revalidator *       revalidators;         /*    48     8 */
          uint32_t                   n_revalidators;       /*    56     4 */
          struct latch               exit_latch;           /*    60     8 */

          /* XXX 4 bytes hole, try to pack */

          /* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
          struct seq *               reval_seq;            /*    72     8 */
          _Bool                      reval_exit;           /*    80     1 */

          /* XXX 7 bytes hole, try to pack */

          struct ovs_barrier         reval_barrier;        /*    88     8 */
          struct dpif_flow_dump *    dump;                 /*    96     8 */
          long long int              dump_duration;        /*   104     8 */
          struct seq *               dump_seq;             /*   112     8 */
          atomic_bool                enable_ufid;          /*   120     1 */
          _Bool                      pause;                /*   121     1 */

          /* XXX 2 bytes hole, try to pack */

          struct latch               pause_latch;          /*   124     8 */

          /* XXX 4 bytes hole, try to pack */

          /* --- cacheline 2 boundary (128 bytes) was 8 bytes ago --- */
          struct ovs_barrier         pause_barrier;        /*   136     8 */
          struct umap *              ukeys;                /*   144     8 */
          unsigned int               max_n_flows;          /*   152     4 */
          unsigned int               avg_n_flows;          /*   156     4 */
          atomic_uint                flow_limit;           /*   160     4 */
          atomic_uint                n_flows;              /*   164     4 */
          atomic_llong               n_flows_timestamp;    /*   168     8 */
          struct ovs_mutex           n_flows_mutex;        /*   176    48 */
          /* --- cacheline 3 boundary (192 bytes) was 32 bytes ago --- */
          struct unixctl_conn * *    conns;                /*   224     8 */
          uint64_t                   conn_seq;             /*   232     8 */
          size_t                     n_conns;              /*   240     8 */
          long long int              offload_rebalance_time; /*   248     8 */

          /* size: 256, cachelines: 4, members: 29 */
          /* sum members: 235, holes: 5, sum holes: 21 */
  };

  $

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarves_fprintf.c | 15 +++++++++++----
 1 file changed, 11 insertions(+), 4 deletions(-)

diff --git a/dwarves_fprintf.c b/dwarves_fprintf.c
index a3193eb..5035f55 100644
--- a/dwarves_fprintf.c
+++ b/dwarves_fprintf.c
@@ -767,6 +767,8 @@ inner_struct:
 		tconf.suppress_offset_comment = suppress_offset_comment;
 	}
 
+	const char *modifier;
+
 next_type:
 	switch (type->tag) {
 	case DW_TAG_pointer_type:
@@ -808,10 +810,15 @@ print_default:
 		printed += ftype__fprintf(tag__ftype(type), cu, name, 0, 0,
 					  tconf.type_spacing, true, &tconf, fp);
 		break;
-	case DW_TAG_const_type: {
-		size_t const_printed = fprintf(fp, "%s ", "const");
-		tconf.type_spacing -= const_printed;
-		printed		   += const_printed;
+	case DW_TAG_atomic_type:
+		modifier = "_Atomic";
+		goto print_modifier;
+	case DW_TAG_const_type:
+		modifier = "const";
+print_modifier: {
+		size_t modifier_printed = fprintf(fp, "%s ", modifier);
+		tconf.type_spacing -= modifier_printed;
+		printed		   += modifier_printed;
 
 		struct tag *ttype = cu__type(cu, type->type);
 		if (ttype) {
-- 
2.39.1


From 121a46a026afac197652cb8a4cdf2d3879d7f587 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Mon, 10 Oct 2022 09:34:53 -0300
Subject: [PATCH 14/29] btf_encoder: Store the CU being processed to avoid
 changing many functions

Having it as encoder->cu will make it available to nested function
without requiring changing all the functions leading to them.

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 btf_encoder.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/btf_encoder.c b/btf_encoder.c
index 7ad3f29..fb2ca77 100644
--- a/btf_encoder.c
+++ b/btf_encoder.c
@@ -44,9 +44,13 @@ struct var_info {
 	uint32_t    sz;
 };
 
+/*
+ * cu: cu being processed.
+ */
 struct btf_encoder {
 	struct list_head  node;
 	struct btf        *btf;
+	struct cu         *cu;
 	struct gobuffer   percpu_secinfo;
 	const char	  *filename;
 	struct elf_symtab *symtab;
@@ -1255,8 +1259,9 @@ static bool ftype__has_arg_names(const struct ftype *ftype)
 	return true;
 }
 
-static int btf_encoder__encode_cu_variables(struct btf_encoder *encoder, struct cu *cu, uint32_t type_id_off)
+static int btf_encoder__encode_cu_variables(struct btf_encoder *encoder, uint32_t type_id_off)
 {
+	struct cu *cu = encoder->cu;
 	uint32_t core_id;
 	struct tag *pos;
 	int err = -1;
@@ -1488,6 +1493,7 @@ int btf_encoder__encode_cu(struct btf_encoder *encoder, struct cu *cu, struct co
 	struct tag *pos;
 	int err = 0;
 
+	encoder->cu = cu;
 
 	if (!encoder->has_index_type) {
 		/* cu__find_base_type_by_name() takes "type_id_t *id" */
@@ -1603,8 +1609,9 @@ int btf_encoder__encode_cu(struct btf_encoder *encoder, struct cu *cu, struct co
 	}
 
 	if (!encoder->skip_encoding_vars)
-		err = btf_encoder__encode_cu_variables(encoder, cu, type_id_off);
+		err = btf_encoder__encode_cu_variables(encoder, type_id_off);
 out:
+	encoder->cu = NULL;
 	return err;
 }
 
-- 
2.39.1


From 75e0fe28bb02036dd404eec53dc3b71b55684ed1 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Mon, 10 Oct 2022 16:59:53 -0300
Subject: [PATCH 15/29] core: Add DW_TAG_unspecified_type to tag__is_tag_type()
 set

It is a type, so make tag__is_tag_type() return true for it.

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarves.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dwarves.h b/dwarves.h
index d1aa240..9aaf87f 100644
--- a/dwarves.h
+++ b/dwarves.h
@@ -547,6 +547,7 @@ static inline int tag__is_tag_type(const struct tag *tag)
 	       tag->tag == DW_TAG_unspecified_type ||
 	       tag->tag == DW_TAG_volatile_type ||
 	       tag->tag == DW_TAG_atomic_type ||
+	       tag->tag == DW_TAG_unspecified_type ||
 	       tag->tag == DW_TAG_LLVM_annotation;
 }
 
-- 
2.39.1


From cffe5e1f75e1612e1ffd8da5fab30e0230fbcdd4 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Mon, 10 Oct 2022 09:42:30 -0300
Subject: [PATCH 16/29] core: Record if a CU has a DW_TAG_unspecified_type

So that the BTF encoder can turn such functions into returning void
instead, as BTF doesn't have a representation for such tags.

First noticed with Linux circa v6.1 built with GNU AS 2.39.50, git
HEAD at the time building a .S file where the entry_ibpb assembly
"function" was encoded as DWARF with DW_TAG_unspecified_type as its
return type.

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarf_loader.c | 7 ++++++-
 dwarves.h      | 8 ++++++++
 2 files changed, 14 insertions(+), 1 deletion(-)

diff --git a/dwarf_loader.c b/dwarf_loader.c
index 28a912e..03ac871 100644
--- a/dwarf_loader.c
+++ b/dwarf_loader.c
@@ -2006,10 +2006,12 @@ static struct tag *__die__process_tag(Dwarf_Die *die, struct cu *cu,
 	case DW_TAG_imported_module:
 	case DW_TAG_reference_type:
 	case DW_TAG_restrict_type:
-	case DW_TAG_unspecified_type:
 	case DW_TAG_volatile_type:
 	case DW_TAG_atomic_type:
 		tag = die__create_new_tag(die, cu);		break;
+	case DW_TAG_unspecified_type:
+		cu->unspecified_type.tag =
+			tag = die__create_new_tag(die, cu);     break;
 	case DW_TAG_pointer_type:
 		tag = die__create_new_pointer_tag(die, cu, conf);	break;
 	case DW_TAG_ptr_to_member_type:
@@ -2077,6 +2079,8 @@ static int die__process_unit(Dwarf_Die *die, struct cu *cu, struct conf_load *co
 		cu__hash(cu, tag);
 		struct dwarf_tag *dtag = tag->priv;
 		dtag->small_id = id;
+		if (tag->tag == DW_TAG_unspecified_type)
+			cu->unspecified_type.type = id;
 	} while (dwarf_siblingof(die, die) == 0);
 
 	return 0;
@@ -2512,6 +2516,7 @@ static int cu__recode_dwarf_types_table(struct cu *cu,
 			if (tag__recode_dwarf_type(tag, cu))
 				return -1;
 	}
+
 	return 0;
 }
 
diff --git a/dwarves.h b/dwarves.h
index 9aaf87f..f8b1500 100644
--- a/dwarves.h
+++ b/dwarves.h
@@ -230,6 +230,10 @@ struct debug_fmt_ops {
 	bool		   has_alignment_info;
 };
 
+/*
+ * unspecified_type: If this CU has a DW_TAG_unspecified_type, as BTF doesn't have a representation for this
+ * 		     and thus we need to check functions returning this to convert it to void.
+ */
 struct cu {
 	struct list_head node;
 	struct list_head tags;
@@ -238,6 +242,10 @@ struct cu {
 	struct ptr_table functions_table;
 	struct ptr_table tags_table;
 	struct rb_root	 functions;
+	struct {
+		struct tag	 *tag;
+		uint32_t	 type;
+	} unspecified_type;
 	char		 *name;
 	char		 *filename;
 	void 		 *priv;
-- 
2.39.1


From bcc648a10cbcd0b96b84ff7c737d56ce70f7b501 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Mon, 10 Oct 2022 11:20:07 -0300
Subject: [PATCH 17/29] btf_encoder: Encode DW_TAG_unspecified_type returning
 routines as void
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Since we don´t have how to encode this info in BTF, and from what we
saw, at least in this case:

Built binutils from git://sourceware.org/git/binutils-gdb.git, then used
gcc's -B option to point to the directory with the new as, that is built
as as-new, so make a symlink, ending up with:

  15e20ce2324a:~/git/linux # readelf -wi ./arch/x86/entry/entry.o
  Contents of the .debug_info section:

    Compilation Unit @ offset 0:
     Length:        0x35 (32-bit)
     Version:       5
     Unit Type:     DW_UT_compile (1)
     Abbrev Offset: 0
     Pointer Size:  8
   <0><c>: Abbrev Number: 1 (DW_TAG_compile_unit)
      <d>   DW_AT_stmt_list   : 0
      <11>   DW_AT_low_pc      : 0
      <19>   DW_AT_high_pc     : 19
      <1a>   DW_AT_name        : (indirect string, offset: 0): arch/x86/entry/entry.S
      <1e>   DW_AT_comp_dir    : (indirect string, offset: 0x17): /root/git/linux
      <22>   DW_AT_producer    : (indirect string, offset: 0x27): GNU AS 2.39.50
      <26>   DW_AT_language    : 32769  (MIPS assembler)
   <1><28>: Abbrev Number: 2 (DW_TAG_subprogram)
      <29>   DW_AT_name        : (indirect string, offset: 0x36): entry_ibpb
      <2d>   DW_AT_external    : 1
      <2d>   DW_AT_type        : <0x37>
      <2e>   DW_AT_low_pc      : 0
      <36>   DW_AT_high_pc     : 19
   <1><37>: Abbrev Number: 3 (DW_TAG_unspecified_type)
   <1><38>: Abbrev Number: 0

So we have that asm label encoded by GNU AS 2.39.50 as a
DW_TAG_subprogram that has as its DW_AT_type the DW_TAG_unspecified_type
0x37 that we convert to 0 (void):

  15e20ce2324a:~/git/linux # pahole -J ./arch/x86/entry/entry.o
  15e20ce2324a:~/git/linux # pahole -JV ./arch/x86/entry/entry.o
  btf_encoder__new: 'entry.o' doesn't have '.data..percpu' section
  Found 0 per-CPU variables!
  Found 1 functions!
  File entry.o:
  [1] FUNC_PROTO (anon) return=0 args=(void)
  [2] FUNC entry_ibpb type_id=1
  15e20ce2324a:~/git/linux # pfunct -F btf ./arch/x86/entry/entry.o
  entry_ibpb
  15e20ce2324a:~/git/linux # pfunct --proto -F btf ./arch/x86/entry/entry.o
  void  entry_ibpb(void);
  15e20ce2324a:~/git/linux #

  15e20ce2324a:~/git/linux # tools/bpf/bpftool/bpftool btf dump file ./arch/x86/entry/entry.o format raw
  [1] FUNC_PROTO '(anon)' ret_type_id=0 vlen=0
  [2] FUNC 'entry_ibpb' type_id=1 linkage=static
  15e20ce2324a:~/git/linux #

I think this is what can be done to avoid having to skip ASM DWARF when
gets widely used, i.e. binutils gets updated.

Acked-by: Yonghong Song <yhs@fb.com>
Cc: Andrii Nakryiko <andrii.nakryiko@gmail.com>,
Cc: Martin Liška <mliska@suse.cz>
Link: https://lore.kernel.org/all/Y0R7uu3s%2FimnvPzM@kernel.org/
Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 btf_encoder.c | 33 ++++++++++++++++++++++++++++++---
 1 file changed, 30 insertions(+), 3 deletions(-)

diff --git a/btf_encoder.c b/btf_encoder.c
index fb2ca77..a5fa04a 100644
--- a/btf_encoder.c
+++ b/btf_encoder.c
@@ -593,6 +593,19 @@ static int32_t btf_encoder__add_func_param(struct btf_encoder *encoder, const ch
 	}
 }
 
+static int32_t btf_encoder__tag_type(struct btf_encoder *encoder, uint32_t type_id_off, uint32_t tag_type)
+{
+	if (tag_type == 0)
+		return 0;
+
+	if (encoder->cu->unspecified_type.tag && tag_type == encoder->cu->unspecified_type.type) {
+		// No provision for encoding this, turn it into void.
+		return 0;
+	}
+
+	return type_id_off + tag_type;
+}
+
 static int32_t btf_encoder__add_func_proto(struct btf_encoder *encoder, struct ftype *ftype, uint32_t type_id_off)
 {
 	struct btf *btf = encoder->btf;
@@ -603,7 +616,7 @@ static int32_t btf_encoder__add_func_proto(struct btf_encoder *encoder, struct f
 
 	/* add btf_type for func_proto */
 	nr_params = ftype->nr_parms + (ftype->unspec_parms ? 1 : 0);
-	type_id = ftype->tag.type == 0 ? 0 : type_id_off + ftype->tag.type;
+	type_id = btf_encoder__tag_type(encoder, type_id_off, ftype->tag.type);
 
 	id = btf__add_func_proto(btf, type_id);
 	if (id > 0) {
@@ -966,6 +979,15 @@ static int btf_encoder__encode_tag(struct btf_encoder *encoder, struct tag *tag,
 		return btf_encoder__add_enum_type(encoder, tag, conf_load);
 	case DW_TAG_subroutine_type:
 		return btf_encoder__add_func_proto(encoder, tag__ftype(tag), type_id_off);
+        case DW_TAG_unspecified_type:
+		/* Just don't encode this for now, converting anything with this type to void (0) instead.
+		 *
+		 * If we end up needing to encode this, one possible hack is to do as follows, as "const void".
+		 *
+		 * Returning zero means we skipped encoding a DWARF type.
+		 */
+               // btf_encoder__add_ref_type(encoder, BTF_KIND_CONST, 0, NULL, false);
+               return 0;
 	default:
 		fprintf(stderr, "Unsupported DW_TAG_%s(0x%x): type: 0x%x\n",
 			dwarf_tag_name(tag->tag), tag->tag, ref_type_id);
@@ -1487,7 +1509,7 @@ int btf_encoder__encode_cu(struct btf_encoder *encoder, struct cu *cu, struct co
 {
 	uint32_t type_id_off = btf__type_cnt(encoder->btf) - 1;
 	struct llvm_annotation *annot;
-	int btf_type_id, tag_type_id;
+	int btf_type_id, tag_type_id, skipped_types = 0;
 	uint32_t core_id;
 	struct function *fn;
 	struct tag *pos;
@@ -1510,8 +1532,13 @@ int btf_encoder__encode_cu(struct btf_encoder *encoder, struct cu *cu, struct co
 	cu__for_each_type(cu, core_id, pos) {
 		btf_type_id = btf_encoder__encode_tag(encoder, pos, type_id_off, conf_load);
 
+		if (btf_type_id == 0) {
+			++skipped_types;
+			continue;
+		}
+
 		if (btf_type_id < 0 ||
-		    tag__check_id_drift(pos, core_id, btf_type_id, type_id_off)) {
+		    tag__check_id_drift(pos, core_id, btf_type_id + skipped_types, type_id_off)) {
 			err = -1;
 			goto out;
 		}
-- 
2.39.1


From a4f3a79da8d4ed8b8199d98241c387c3f7684df3 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Tue, 11 Oct 2022 16:27:18 -0300
Subject: [PATCH 18/29] emit: cu__type() == NULL means "void"

Fix it to cope with:

typedef void foo;

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarves_emit.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dwarves_emit.c b/dwarves_emit.c
index dec446d..bbfc840 100644
--- a/dwarves_emit.c
+++ b/dwarves_emit.c
@@ -155,7 +155,8 @@ static int typedef__emit_definitions(struct tag *tdef, struct cu *cu,
 	}
 
 	type = cu__type(cu, tdef->type);
-	tag__assert_search_result(type, tdef->tag, type__name(def));
+	if (type == NULL) // void
+		goto emit;
 
 	switch (type->tag) {
 	case DW_TAG_array_type:
@@ -215,6 +216,7 @@ static int typedef__emit_definitions(struct tag *tdef, struct cu *cu,
 	 * will thus be emitted before the function typedef, making a no go to
 	 * redefine the typedef after struct __wait_queue.
 	 */
+emit:
 	if (!def->definition_emitted) {
 		typedef__fprintf(tdef, cu, NULL, fp);
 		fputs(";\n", fp);
-- 
2.39.1


From 8c2b37ec71423067b028eeaea8a450abe99a601c Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Thu, 13 Oct 2022 13:05:13 -0300
Subject: [PATCH 19/29] emit: Emit typedefs for atomic_ prefixed base types
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

That appear as DW_TAG_base_type, and since:

  atomic_int foo;

is equivalent to:

  _Atomic int foo;

Emit:

  typedef _Atomic int atomic_int;

So that we can make 'pahole --compile' work in these cases as well.

This will be selectable in pahole, in case we find some compiler that
either emits DWARF tags for these typedefs or that recognizes them
directly, without the need for these typedefs.

Doing this with an openvswitch file:

  $ pahole --compile eelco/ovs-vswitchd_rhel8 > vswitchd_rhel8.c ; echo "static struct dpif_userdata data;" >> vswitchd_rhel8.c ; gcc -g -c vswitchd_rhel8.c -o vswitchd_rhel8.o |& head
  vswitchd_rhel8.c:8493:33: error: redeclaration of enumerator ‘ADD’
   8493 |                                 ADD    = 0,
        |                                 ^~~
  vswitchd_rhel8.c:6229:9: note: previous definition of ‘ADD’ with type ‘enum bond_op’
   6229 |         ADD = 0,
        |         ^~~
  vswitchd_rhel8.c:12910:9: error: redeclaration of enumerator ‘ADD’
  12910 |         ADD = 0,
        |         ^~~
  vswitchd_rhel8.c:8493:33: note: previous definition of ‘ADD’ with type ‘enum <anonymous>’

Fails at first for some unrelated reason, i.e. multiple different enums
from multiple compile units that have the sane enumerator, if we
manually go and make them unique, adding some different suffixes, we go
to:

  $ vim vswitchd_rhel8.c
  $ gcc -g -c vswitchd_rhel8.c -o vswitchd_rhel8.o
  $ grep "typedef _Atomic " vswitchd_rhel8.c
  typedef _Atomic  size_t atomic_size_t;
  typedef _Atomic unsigned long atomic_ulong;
  typedef _Atomic unsigned int atomic_uint;
  typedef _Atomic _Bool atomic_bool;
  typedef _Atomic long long atomic_llong;
  typedef _Atomic unsigned int atomic_uint32_t;
  typedef _Atomic unsigned long long atomic_ullong;
  typedef _Atomic unsigned short atomic_uint16_t;
  typedef _Atomic unsigned char atomic_uint8_t;
  typedef _Atomic int atomic_int;
  $

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 btf_loader.c   |  1 +
 ctf_loader.c   |  1 +
 dwarf_loader.c |  1 +
 dwarves.h      |  2 ++
 dwarves_emit.c | 88 ++++++++++++++++++++++++++++++++++++++++++++++++++
 dwarves_emit.h |  1 +
 6 files changed, 94 insertions(+)

diff --git a/btf_loader.c b/btf_loader.c
index 69b63a5..e579323 100644
--- a/btf_loader.c
+++ b/btf_loader.c
@@ -108,6 +108,7 @@ static struct base_type *base_type__new(const char *name, uint32_t attrs,
 		bt->is_bool = attrs & BTF_INT_BOOL;
 		bt->name_has_encoding = false;
 		bt->float_type = float_type;
+		INIT_LIST_HEAD(&bt->node);
 	}
 	return bt;
 }
diff --git a/ctf_loader.c b/ctf_loader.c
index de6d4db..2570b09 100644
--- a/ctf_loader.c
+++ b/ctf_loader.c
@@ -157,6 +157,7 @@ static struct base_type *base_type__new(const char *name, uint32_t attrs,
 		bt->is_varargs = attrs & CTF_TYPE_INT_VARARGS;
 		bt->name_has_encoding = false;
 		bt->float_type = float_type;
+		INIT_LIST_HEAD(&bt->node);
 	}
 	return bt;
 }
diff --git a/dwarf_loader.c b/dwarf_loader.c
index 03ac871..5a74035 100644
--- a/dwarf_loader.c
+++ b/dwarf_loader.c
@@ -564,6 +564,7 @@ static struct base_type *base_type__new(Dwarf_Die *die, struct cu *cu, struct co
 		bt->is_varargs = false;
 		bt->name_has_encoding = true;
 		bt->float_type = encoding_to_float_type(encoding);
+		INIT_LIST_HEAD(&bt->node);
 	}
 
 	return bt;
diff --git a/dwarves.h b/dwarves.h
index f8b1500..9b7c922 100644
--- a/dwarves.h
+++ b/dwarves.h
@@ -1334,12 +1334,14 @@ enum base_type_float_type {
 struct base_type {
 	struct tag	tag;
 	const char	*name;
+	struct list_head node;
 	uint16_t	bit_size;
 	uint8_t		name_has_encoding:1;
 	uint8_t		is_signed:1;
 	uint8_t		is_bool:1;
 	uint8_t		is_varargs:1;
 	uint8_t		float_type:4;
+	uint8_t		definition_emitted:1;
 };
 
 static inline struct base_type *tag__base_type(const struct tag *tag)
diff --git a/dwarves_emit.c b/dwarves_emit.c
index bbfc840..04b3de4 100644
--- a/dwarves_emit.c
+++ b/dwarves_emit.c
@@ -15,6 +15,7 @@
 
 void type_emissions__init(struct type_emissions *emissions)
 {
+	INIT_LIST_HEAD(&emissions->base_type_definitions);
 	INIT_LIST_HEAD(&emissions->definitions);
 	INIT_LIST_HEAD(&emissions->fwd_decls);
 }
@@ -253,6 +254,91 @@ static int type__emit_fwd_decl(struct type *ctype, struct type_emissions *emissi
 	return 1;
 }
 
+static struct base_type *base_type_emissions__find_definition(const struct type_emissions *emissions, const char *name)
+{
+	struct base_type *pos;
+
+	if (name == NULL)
+		return NULL;
+
+	list_for_each_entry(pos, &emissions->base_type_definitions, node)
+		if (strcmp(__base_type__name(pos), name) == 0)
+			return pos;
+
+	return NULL;
+}
+
+static void base_type_emissions__add_definition(struct type_emissions *emissions, struct base_type *type)
+{
+	type->definition_emitted = 1;
+	if (!list_empty(&type->node))
+		list_del(&type->node);
+	list_add_tail(&type->node, &emissions->base_type_definitions);
+}
+
+static const char *base_type__stdint2simple(const char *name)
+{
+	if (strcmp(name, "int32_t") == 0)
+		return "int";
+	if (strcmp(name, "int16_t") == 0)
+		return "short";
+	if (strcmp(name, "int8_t") == 0)
+		return "char";
+	if (strcmp(name, "int64_t") == 0)
+		return "long";
+	return name;
+}
+
+static int base_type__emit_definitions(struct base_type *type, struct type_emissions *emissions, FILE *fp)
+{
+#define base_type__prefix "atomic_"
+	const size_t prefixlen = sizeof(base_type__prefix) - 1;
+	const char *name = __base_type__name(type);
+
+	// See if it was already emitted in this CU
+	if (type->definition_emitted)
+		return 0;
+
+	// We're only emitting for "atomic_" prefixed base types
+	if (strncmp(name, base_type__prefix, prefixlen) != 0)
+		return 0;
+
+	// See if it was already emitted in another CU
+	if (base_type_emissions__find_definition(emissions, name)) {
+		type->definition_emitted = 1;
+		return 0;
+	}
+
+	const char *non_atomic_name = name + prefixlen;
+
+	fputs("typedef _Atomic", fp);
+
+	if (non_atomic_name[0] == 's' &&
+	    non_atomic_name[1] != 'i' && non_atomic_name[1] != 'h') // exclude atomic_size_t and atomic_short
+		fprintf(fp, " signed %s", non_atomic_name + 1);
+	else if (non_atomic_name[0] == 'l' && non_atomic_name[1] == 'l')
+		fprintf(fp, " long long");
+	else if (non_atomic_name[0] == 'u') {
+		fprintf(fp, " unsigned");
+		if (non_atomic_name[1] == 'l') {
+			fprintf(fp, " long");
+			if (non_atomic_name[2] == 'l')
+				fprintf(fp, " long");
+		} else
+			fprintf(fp, " %s", base_type__stdint2simple(non_atomic_name + 1));
+	} else if (non_atomic_name[0] == 'b')
+		fprintf(fp, " _Bool");
+	else
+		fprintf(fp, " %s", base_type__stdint2simple(non_atomic_name));
+
+	fprintf(fp, " %s;\n", name);
+
+	base_type_emissions__add_definition(emissions, type);
+	return 1;
+
+#undef base_type__prefix
+}
+
 static int tag__emit_definitions(struct tag *tag, struct cu *cu,
 				 struct type_emissions *emissions, FILE *fp)
 {
@@ -263,6 +349,8 @@ static int tag__emit_definitions(struct tag *tag, struct cu *cu,
 		return 0;
 next_indirection:
 	switch (type->tag) {
+	case DW_TAG_base_type:
+		return base_type__emit_definitions(tag__base_type(type), emissions, fp);
 	case DW_TAG_pointer_type:
 	case DW_TAG_reference_type:
 		pointer = 1;
diff --git a/dwarves_emit.h b/dwarves_emit.h
index b153cdb..58af2dd 100644
--- a/dwarves_emit.h
+++ b/dwarves_emit.h
@@ -19,6 +19,7 @@ struct type;
 
 struct type_emissions {
 	struct list_head definitions; /* struct type entries */
+	struct list_head base_type_definitions; /* struct base_type entries */
 	struct list_head fwd_decls;   /* struct class entries */
 };
 
-- 
2.39.1


From 8d2e166dd3d168d9e0bb18bace815dfb0529a757 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Thu, 13 Oct 2022 13:20:00 -0300
Subject: [PATCH 20/29] emit: Optionally pass a conf_fprintf struct to
 type_emissions__init

For later to use it to toggle some features, such as emitting the
atomic_ types as _Atomic typedefs.

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 ctracer.c      | 2 +-
 dwarves_emit.c | 3 ++-
 dwarves_emit.h | 4 +++-
 pahole.c       | 2 +-
 pfunct.c       | 4 ++--
 5 files changed, 9 insertions(+), 6 deletions(-)

diff --git a/ctracer.c b/ctracer.c
index 8d6eac8..cb7e81f 100644
--- a/ctracer.c
+++ b/ctracer.c
@@ -960,7 +960,7 @@ failure:
 		goto out;
 	}
 
-	type_emissions__init(&emissions);
+	type_emissions__init(&emissions, NULL);
 
         /*
          * Create the methods_cus (Compilation Units) object where we will
diff --git a/dwarves_emit.c b/dwarves_emit.c
index 04b3de4..ce252c9 100644
--- a/dwarves_emit.c
+++ b/dwarves_emit.c
@@ -13,11 +13,12 @@
 #include "dwarves_emit.h"
 #include "dwarves.h"
 
-void type_emissions__init(struct type_emissions *emissions)
+void type_emissions__init(struct type_emissions *emissions, struct conf_fprintf *conf_fprintf)
 {
 	INIT_LIST_HEAD(&emissions->base_type_definitions);
 	INIT_LIST_HEAD(&emissions->definitions);
 	INIT_LIST_HEAD(&emissions->fwd_decls);
+	emissions->conf_fprintf = conf_fprintf;
 }
 
 static void type_emissions__add_definition(struct type_emissions *emissions,
diff --git a/dwarves_emit.h b/dwarves_emit.h
index 58af2dd..6022bee 100644
--- a/dwarves_emit.h
+++ b/dwarves_emit.h
@@ -16,14 +16,16 @@ struct cu;
 struct ftype;
 struct tag;
 struct type;
+struct conf_fprintf;
 
 struct type_emissions {
 	struct list_head definitions; /* struct type entries */
 	struct list_head base_type_definitions; /* struct base_type entries */
 	struct list_head fwd_decls;   /* struct class entries */
+	struct conf_fprintf *conf_fprintf;
 };
 
-void type_emissions__init(struct type_emissions *temissions);
+void type_emissions__init(struct type_emissions *temissions, struct conf_fprintf *conf_fprintf);
 
 int ftype__emit_definitions(struct ftype *ftype, struct cu *cu,
 			    struct type_emissions *emissions, FILE *fp);
diff --git a/pahole.c b/pahole.c
index 4636f01..8261171 100644
--- a/pahole.c
+++ b/pahole.c
@@ -1716,7 +1716,7 @@ static error_t pahole__options_parser(int key, char *arg,
 	// case 'Z': ctf_encode = 1;			break; // FIXME: Disabled
 	case ARGP_compile:
 		  compilable = true;
-                  type_emissions__init(&emissions);
+                  type_emissions__init(&emissions, &conf);
                   conf.no_semicolon = true;
                   conf.strip_inline = true;
 		  break;
diff --git a/pfunct.c b/pfunct.c
index 314915b..f42bdd1 100644
--- a/pfunct.c
+++ b/pfunct.c
@@ -658,7 +658,7 @@ static error_t pfunct__options_parser(int key, char *arg,
 	case 'a': addr = strtoull(arg, NULL, 0);
 		  conf_load.get_addr_info = true;	 break;
 	case 'b': expand_types = true;
-		  type_emissions__init(&emissions);	 break;
+		  type_emissions__init(&emissions, &conf);	 break;
 	case 'c': class_name = arg;			 break;
 	case 'f': function_name = arg;			 break;
 	case 'F': conf_load.format_path = arg;		 break;
@@ -689,7 +689,7 @@ static error_t pfunct__options_parser(int key, char *arg,
 	case ARGP_no_parm_names: conf.no_parm_names = 1; break;
 	case ARGP_compile:
 		  expand_types = true;
-		  type_emissions__init(&emissions);
+		  type_emissions__init(&emissions, &conf);
 		  compilable_output = true;
 		  conf.no_semicolon = true;
 		  conf.strip_inline = true;
-- 
2.39.1


From 6bb5a1fa990f5bd6b16355ef44afd8979aaaafb0 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Thu, 13 Oct 2022 13:23:40 -0300
Subject: [PATCH 21/29] emit: Allow skip emitting the atomic typedefs

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarves.h      | 2 ++
 dwarves_emit.c | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/dwarves.h b/dwarves.h
index 9b7c922..589588e 100644
--- a/dwarves.h
+++ b/dwarves.h
@@ -91,6 +91,7 @@ struct conf_load {
  * @suppress_force_paddings: This makes sense only if the debugging format has struct alignment information,
  *                           So allow for it to be disabled and disable it automatically for things like BTF,
  *                           that don't have such info.
+ * @skip_emitting_atomic_typedefs: Allow not emitting "typedef _Atomic int atomic_int;" and friends
  */
 struct conf_fprintf {
 	const char *prefix;
@@ -129,6 +130,7 @@ struct conf_fprintf {
 	uint8_t	   classes_as_structs:1;
 	uint8_t	   hex_fmt:1;
 	uint8_t	   strip_inline:1;
+	uint8_t	   skip_emitting_atomic_typedefs:1;
 };
 
 struct cus;
diff --git a/dwarves_emit.c b/dwarves_emit.c
index ce252c9..102b7c4 100644
--- a/dwarves_emit.c
+++ b/dwarves_emit.c
@@ -351,6 +351,8 @@ static int tag__emit_definitions(struct tag *tag, struct cu *cu,
 next_indirection:
 	switch (type->tag) {
 	case DW_TAG_base_type:
+		if (emissions->conf_fprintf && emissions->conf_fprintf->skip_emitting_atomic_typedefs)
+			return 0;
 		return base_type__emit_definitions(tag__base_type(type), emissions, fp);
 	case DW_TAG_pointer_type:
 	case DW_TAG_reference_type:
-- 
2.39.1


From 3836623af1b5ff1f5869f8db75f564dccdda00fa Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Thu, 13 Oct 2022 13:29:42 -0300
Subject: [PATCH 22/29] pahole: Allow skipping the emission of atomic typedefs
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Just in case we find some compiler that doesn't like pahole generating
those typedefs, that are not present in the DWARF info at least with gcc
12.

Testing it:

  $ type=oftable ; pahole -C $type --compile eelco/ovs-vswitchd_rhel8   > vswitchd_rhel8.c ; echo "static struct ${type} data;" >> vswitchd_rhel8.c ; gcc -g -c vswitchd_rhel8.c -o vswitchd_rhel8.o |& head
  $ grep "typedef _Atomic " vswitchd_rhel8.c
  typedef _Atomic unsigned long atomic_ulong;
  $ type=oftable ; pahole --skip_emitting_atomic_typedefs -C $type --compile eelco/ovs-vswitchd_rhel8   > vswitchd_rhel8.c ; echo "static struct ${type} data;" >> vswitchd_rhel8.c ; gcc -g -c vswitchd_rhel8.c -o vswitchd_rhel8.o |& head
  vswitchd_rhel8.c:155:9: error: unknown type name ‘atomic_ulong’
    155 |         atomic_ulong               n_matched;            /*   224     8 */
        |         ^~~~~~~~~~~~
  vswitchd_rhel8.c:156:9: error: unknown type name ‘atomic_ulong’
    156 |         atomic_ulong               n_missed;             /*   232     8 */
        |         ^~~~~~~~~~~~
  $

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 man-pages/pahole.1 | 8 ++++++++
 pahole.c           | 8 ++++++++
 2 files changed, 16 insertions(+)

diff --git a/man-pages/pahole.1 b/man-pages/pahole.1
index 45a21af..7460104 100644
--- a/man-pages/pahole.1
+++ b/man-pages/pahole.1
@@ -121,6 +121,14 @@ Produces a header that can be included in a C source file and built. In
 the example provided it will use the BTF info if available, otherwise will
 look for a DWARF file matching the running kernel build-id.
 
+.TP
+.B \-\-skip_emitting_atomic_typedefs
+Do not emit 'typedef _Atomic int atomic_int' & friends when used with options
+like --compile. Use it if the compiler provides these already, as of circa
+2022 with gcc 12.2.1 those are not encoded in DWARF so to generate compilable
+code we need emit those typedefs for the atomic types used in the data structures
+being emitted from debugging information.
+
 .TP
 .B \-\-count=COUNT
 Pretty print the first COUNT records from input.
diff --git a/pahole.c b/pahole.c
index 8261171..4ddf21f 100644
--- a/pahole.c
+++ b/pahole.c
@@ -1221,6 +1221,7 @@ ARGP_PROGRAM_VERSION_HOOK_DEF = dwarves_print_version;
 #define ARGP_languages		   335
 #define ARGP_languages_exclude	   336
 #define ARGP_skip_encoding_btf_enum64 337
+#define ARGP_skip_emitting_atomic_typedefs 338
 
 static const struct argp_option pahole__options[] = {
 	{
@@ -1628,6 +1629,11 @@ static const struct argp_option pahole__options[] = {
 		.key  = ARGP_skip_encoding_btf_enum64,
 		.doc  = "Do not encode ENUM64sin BTF."
 	},
+	{
+		.name = "skip_emitting_atomic_typedefs",
+		.key  = ARGP_skip_emitting_atomic_typedefs,
+		.doc  = "Do not emit 'typedef _Atomic int atomic_int' & friends."
+	},
 	{
 		.name = NULL,
 	}
@@ -1795,6 +1801,8 @@ static error_t pahole__options_parser(int key, char *arg,
 		languages.str = arg;			break;
 	case ARGP_skip_encoding_btf_enum64:
 		conf_load.skip_encoding_btf_enum64 = true;	break;
+	case ARGP_skip_emitting_atomic_typedefs:
+		conf.skip_emitting_atomic_typedefs = true;	break;
 	default:
 		return ARGP_ERR_UNKNOWN;
 	}
-- 
2.39.1


From 8894c04f00e4c702ad7c36b69c4808e1908033f9 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Thu, 13 Oct 2022 15:25:44 -0300
Subject: [PATCH 23/29] fprintf: Move the "typedef " invariant printf to the
 start of typedef__fprintf()

Simplifies the code and paves the way to properly support _Atomic (and
other modifiers) typedefs such as:

  typedef _Atomic struct {
          _Bool __val;
  } atomic_flag;

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarves_fprintf.c | 18 +++++++-----------
 1 file changed, 7 insertions(+), 11 deletions(-)

diff --git a/dwarves_fprintf.c b/dwarves_fprintf.c
index 5035f55..a755ef2 100644
--- a/dwarves_fprintf.c
+++ b/dwarves_fprintf.c
@@ -303,32 +303,29 @@ size_t typedef__fprintf(const struct tag *tag, const struct cu *cu,
 	const struct tag *ptr_type;
 	char bf[512];
 	int is_pointer = 0;
-	size_t printed;
+	size_t printed = fprintf(fp, "typedef ");
 
 	/*
 	 * Check for void (humm, perhaps we should have a fake void tag instance
 	 * to avoid all these checks?
 	 */
 	if (tag->type == 0)
-		return fprintf(fp, "typedef void %s", type__name(type));
+		return printed + fprintf(fp, "void %s", type__name(type));
 
 	tag_type = cu__type(cu, tag->type);
 	if (tag_type == NULL) {
-		printed = fprintf(fp, "typedef ");
 		printed += tag__id_not_found_fprintf(fp, tag->type);
 		return printed + fprintf(fp, " %s", type__name(type));
 	}
 
 	switch (tag_type->tag) {
 	case DW_TAG_array_type:
-		printed = fprintf(fp, "typedef ");
 		return printed + array_type__fprintf(tag_type, cu, type__name(type), pconf, fp);
 	case DW_TAG_pointer_type:
 		if (tag_type->type == 0) /* void pointer */
 			break;
 		ptr_type = cu__type(cu, tag_type->type);
 		if (ptr_type == NULL) {
-			printed = fprintf(fp, "typedef ");
 			printed += tag__id_not_found_fprintf(fp, tag_type->type);
 			return printed + fprintf(fp, " *%s", type__name(type));
 		}
@@ -338,7 +335,6 @@ size_t typedef__fprintf(const struct tag *tag, const struct cu *cu,
 		is_pointer = 1;
 		/* Fall thru */
 	case DW_TAG_subroutine_type:
-		printed = fprintf(fp, "typedef ");
 		return printed + ftype__fprintf(tag__ftype(tag_type), cu, type__name(type),
 						0, is_pointer, 0, true, pconf, fp);
 	case DW_TAG_class_type:
@@ -346,27 +342,27 @@ size_t typedef__fprintf(const struct tag *tag, const struct cu *cu,
 		struct type *ctype = tag__type(tag_type);
 
 		if (type__name(ctype) != NULL)
-			return fprintf(fp, "typedef struct %s %s", type__name(ctype), type__name(type));
+			return printed + fprintf(fp, "struct %s %s", type__name(ctype), type__name(type));
 
 		struct conf_fprintf tconf = *pconf;
 
 		tconf.suffix = type__name(type);
-		return fprintf(fp, "typedef ") + __class__fprintf(tag__class(tag_type), cu, &tconf, fp);
+		return printed + __class__fprintf(tag__class(tag_type), cu, &tconf, fp);
 	}
 	case DW_TAG_enumeration_type: {
 		struct type *ctype = tag__type(tag_type);
 
 		if (type__name(ctype) != NULL)
-			return fprintf(fp, "typedef enum %s %s", type__name(ctype), type__name(type));
+			return printed + fprintf(fp, "enum %s %s", type__name(ctype), type__name(type));
 
 		struct conf_fprintf tconf = *pconf;
 
 		tconf.suffix = type__name(type);
-		return fprintf(fp, "typedef ") + enumeration__fprintf(tag_type, &tconf, fp);
+		return printed + enumeration__fprintf(tag_type, &tconf, fp);
 	}
 	}
 
-	return fprintf(fp, "typedef %s %s",
+	return printed + fprintf(fp, "%s %s",
 		       tag__name(tag_type, cu, bf, sizeof(bf), pconf), type__name(type));
 }
 
-- 
2.39.1


From 7d0bc9334d2f1143a8682b141eda79f8be1bd5d2 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Thu, 13 Oct 2022 15:30:19 -0300
Subject: [PATCH 24/29] fprintf: Support _Atomic typedefs
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Now this works:

 <1><1cf46e>: Abbrev Number: 91 (DW_TAG_base_type)
    <1cf46f>   DW_AT_byte_size   : 1
    <1cf470>   DW_AT_encoding    : 2    (boolean)
    <1cf471>   DW_AT_name        : (indirect string, offset: 0x91ef): _Bool
 <1><1d1a3c>: Abbrev Number: 71 (DW_TAG_structure_type)
    <1d1a3d>   DW_AT_byte_size   : 1
    <1d1a3e>   DW_AT_decl_file   : 87
    <1d1a3f>   DW_AT_decl_line   : 218
    <1d1a40>   DW_AT_decl_column : 17
    <1d1a41>   DW_AT_sibling     : <0x1d1a53>
 <2><1d1a45>: Abbrev Number: 7 (DW_TAG_member)
    <1d1a46>   DW_AT_name        : (indirect string, offset: 0xfb0): __val
    <1d1a4a>   DW_AT_decl_file   : 87
    <1d1a4b>   DW_AT_decl_line   : 221
    <1d1a4c>   DW_AT_decl_column : 9
    <1d1a4d>   DW_AT_type        : <0x1cf46e>
    <1d1a51>   DW_AT_data_member_location: 0
 <2><1d1a52>: Abbrev Number: 0
 <1><1d1a53>: Abbrev Number: 66 (DW_TAG_atomic_type)
    <1d1a54>   DW_AT_type        : <0x1d1a3c>
 <1><1d1a58>: Abbrev Number: 51 (DW_TAG_typedef)
    <1d1a59>   DW_AT_name        : (indirect string, offset: 0x363b3): atomic_flag
    <1d1a5d>   DW_AT_decl_file   : 87
    <1d1a5e>   DW_AT_decl_line   : 225
    <1d1a5f>   DW_AT_decl_column : 3
    <1d1a60>   DW_AT_type        : <0x1d1a53>

⬢[acme@toolbox pahole]$ grep -A5 'typedef _Atomic struct {' ovs-vswitchd_f35.c
typedef _Atomic struct {
	_Bool                      __val;                /*     0     1 */

	/* size: 1, cachelines: 1, members: 1 */
	/* last cacheline: 1 bytes */
} atomic_flag;
⬢[acme@toolbox pahole]$

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarves_fprintf.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/dwarves_fprintf.c b/dwarves_fprintf.c
index a755ef2..e62bce1 100644
--- a/dwarves_fprintf.c
+++ b/dwarves_fprintf.c
@@ -311,7 +311,7 @@ size_t typedef__fprintf(const struct tag *tag, const struct cu *cu,
 	 */
 	if (tag->type == 0)
 		return printed + fprintf(fp, "void %s", type__name(type));
-
+next_type:
 	tag_type = cu__type(cu, tag->type);
 	if (tag_type == NULL) {
 		printed += tag__id_not_found_fprintf(fp, tag->type);
@@ -319,6 +319,10 @@ size_t typedef__fprintf(const struct tag *tag, const struct cu *cu,
 	}
 
 	switch (tag_type->tag) {
+	case DW_TAG_atomic_type:
+		printed += fprintf(fp, "_Atomic ");
+		tag = tag_type;
+		goto next_type;
 	case DW_TAG_array_type:
 		return printed + array_type__fprintf(tag_type, cu, type__name(type), pconf, fp);
 	case DW_TAG_pointer_type:
-- 
2.39.1


From d85b86ecc1df40761320a177e79556ee9d574e13 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Thu, 13 Oct 2022 15:46:58 -0300
Subject: [PATCH 25/29] emit: Support DW_TAG_atomic_type when emitting
 definitions for a typedef

I.e. now this works:

  typedef unsigned int __uint32_t;
  typedef __uint32_t uint32_t;
  typedef _Atomic uint32_t atomic_uint32_t;

That is, emitting the atomic_uint32_t works as it notices its _Atomic
that points to uint32_t and then fprintfs it and __uint32_t.

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarves_emit.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dwarves_emit.c b/dwarves_emit.c
index 102b7c4..01b33b7 100644
--- a/dwarves_emit.c
+++ b/dwarves_emit.c
@@ -161,6 +161,13 @@ static int typedef__emit_definitions(struct tag *tdef, struct cu *cu,
 		goto emit;
 
 	switch (type->tag) {
+	case DW_TAG_atomic_type:
+		type = cu__type(cu, tdef->type);
+		if (type)
+			tag__emit_definitions(type, cu, emissions, fp);
+		else
+			fprintf(stderr, "%s: couldn't find the type pointed from _Atomic for '%s'\n", __func__, type__name(def));
+		break;
 	case DW_TAG_array_type:
 		tag__emit_definitions(type, cu, emissions, fp);
 		break;
-- 
2.39.1


From b72f5188856df0abf45e1a707856bb4e4e86153c Mon Sep 17 00:00:00 2001
From: Alan Maguire <alan.maguire@oracle.com>
Date: Fri, 21 Oct 2022 16:02:03 +0100
Subject: [PATCH 26/29] dwarves: Zero-initialize struct cu in cu__new() to
 prevent incorrect BTF types

BTF deduplication was throwing some strange results, where core kernel
data types were failing to deduplicate due to the return values
of function type members being void (0) instead of the actual type
(unsigned int).  An example of this can be seen below, where
"struct dst_ops" was failing to deduplicate between kernel and
module:

struct dst_ops {
        short unsigned int family;
        unsigned int gc_thresh;
        int (*gc)(struct dst_ops *);
        struct dst_entry * (*check)(struct dst_entry *, __u32);
        unsigned int (*default_advmss)(const struct dst_entry *);
        unsigned int (*mtu)(const struct dst_entry *);
...

struct dst_ops___2 {
        short unsigned int family;
        unsigned int gc_thresh;
        int (*gc)(struct dst_ops___2 *);
        struct dst_entry___2 * (*check)(struct dst_entry___2 *, __u32);
        void (*default_advmss)(const struct dst_entry___2 *);
        void (*mtu)(const struct dst_entry___2 *);
...

This was seen with

bcc648a10cbc ("btf_encoder: Encode DW_TAG_unspecified_type returning routines as void")

...which rewrites the return value as 0 (void) when it is marked
as matching DW_TAG_unspecified_type:

static int32_t btf_encoder__tag_type(struct btf_encoder *encoder, uint32_t type_id_off, uint32_t tag_type)
{
       if (tag_type == 0)
               return 0;

       if (encoder->cu->unspecified_type.tag && tag_type == encoder->cu->unspecified_type.type) {
               // No provision for encoding this, turn it into void.
               return 0;
       }

       return type_id_off + tag_type;
}

However the odd thing was that on further examination, the unspecified type
was not being set, so why was this logic being tripped?  Futher debugging
showed that the encoder->cu->unspecified_type.tag value was garbage, and
the type id happened to collide with "unsigned int"; as a result we
were replacing unsigned ints with void return values, and since this
was being done to function type members in structs, it triggered a
type mismatch which failed deduplication between kernel and module.

The fix is simply to calloc() the cu in cu__new() instead.

Committer notes:

We have zalloc(size) as an alias to calloc(1, size), use it instead.

Fixes: bcc648a10cbcd0b9 ("btf_encoder: Encode DW_TAG_unspecified_type returning routines as void")
Signed-off-by: Alan Maguire <alan.maguire@oracle.com>
Acked-by: Andrii Nakryiko <andrii@kernel.org>
Acked-by: Jiri Olsa <jolsa@kernel.org>
Cc: bpf@vger.kernel.org
Cc: dwarves@vger.kernel.org
Link: https://lore.kernel.org/r/1666364523-9648-1-git-send-email-alan.maguire@oracle.com
Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarves.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dwarves.c b/dwarves.c
index fbebc1d..95a3bac 100644
--- a/dwarves.c
+++ b/dwarves.c
@@ -626,7 +626,7 @@ struct cu *cu__new(const char *name, uint8_t addr_size,
 		   const unsigned char *build_id, int build_id_len,
 		   const char *filename, bool use_obstack)
 {
-	struct cu *cu = malloc(sizeof(*cu) + build_id_len);
+	struct cu *cu = zalloc(sizeof(*cu) + build_id_len);
 
 	if (cu != NULL) {
 		uint32_t void_id;
-- 
2.39.1


From e5e24ada4f5578ae921539280e4716a41bfd95cc Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Mon, 24 Oct 2022 11:25:44 -0300
Subject: [PATCH 27/29] core: Use zalloc() to make the code more robust

Recently we had a problem where it was assumed that a field was
initialized to zeros but the constructor was using malloc(), check
all use and switch cus__new() to zalloc() to prevent such problems.

The other cases are clone() operations, so no sense in zeroing newly
allocated memory since it will be copied from some other similar
struct.

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 dwarves.c | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/dwarves.c b/dwarves.c
index 95a3bac..b8681bc 100644
--- a/dwarves.c
+++ b/dwarves.c
@@ -2586,12 +2586,9 @@ int cus__fprintf_load_files_err(struct cus *cus __maybe_unused, const char *tool
 
 struct cus *cus__new(void)
 {
-	struct cus *cus = malloc(sizeof(*cus));
+	struct cus *cus = zalloc(sizeof(*cus));
 
 	if (cus != NULL) {
-		cus->nr_entries  = 0;
-		cus->priv	 = NULL;
-		cus->loader_exit = NULL;
 		INIT_LIST_HEAD(&cus->cus);
 		pthread_mutex_init(&cus->mutex, NULL);
 	}
-- 
2.39.1


From cd4d2d251e9a7f982be660f62ff9833506dfba10 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Mon, 24 Oct 2022 11:25:44 -0300
Subject: [PATCH 28/29] pahole: Use zalloc() to make the code more robust

Recently we had a problem where it was assumed that a field was
initialized to zeros but the constructor was using malloc(), check all
use and switch the ones allocating structs to zalloc() to prevent such
problems if we add extra fields to those structs.

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 pahole.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/pahole.c b/pahole.c
index 4ddf21f..6f4f87c 100644
--- a/pahole.c
+++ b/pahole.c
@@ -104,11 +104,10 @@ struct structure {
 
 static struct structure *structure__new(struct class *class, struct cu *cu, uint32_t id)
 {
-	struct structure *st = malloc(sizeof(*st));
+	struct structure *st = zalloc(sizeof(*st));
 
 	if (st != NULL) {
 		st->nr_files   = 1;
-		st->nr_methods = 0;
 		st->class      = class;
 		st->cu	       = cu;
 		st->id	       = id;
@@ -148,7 +147,7 @@ static int parse_languages(void)
 	int nr_allocated = 4;
 	char *lang = languages.str;
 
-	languages.entries = malloc(sizeof(int) * nr_allocated);
+	languages.entries = zalloc(sizeof(int) * nr_allocated);
 	if (languages.entries == NULL)
 		goto out_enomem;
 
@@ -2245,7 +2244,7 @@ static struct type_instance *type_instance__new(struct type *type, struct cu *cu
 	if (type == NULL)
 		return NULL;
 
-	struct type_instance *instance = malloc(sizeof(*instance) + type->size);
+	struct type_instance *instance = zalloc(sizeof(*instance) + type->size);
 
 	if (instance) {
 		instance->type = type;
@@ -2711,7 +2710,7 @@ static int class_member_filter__parse(struct class_member_filter *filter, struct
 
 static struct class_member_filter *class_member_filter__new(struct type *type, char *sfilter)
 {
-	struct class_member_filter *filter = malloc(sizeof(*filter));
+	struct class_member_filter *filter = zalloc(sizeof(*filter));
 
 	if (filter && class_member_filter__parse(filter, type, sfilter)) {
 		free(filter);
@@ -2865,7 +2864,7 @@ static void prototype__delete(struct prototype *prototype)
 
 static struct tag_cu_node *tag_cu_node__new(struct tag *tag, struct cu *cu)
 {
-	struct tag_cu_node *tc = malloc(sizeof(*tc));
+	struct tag_cu_node *tc = zalloc(sizeof(*tc));
 
 	if (tc) {
 		tc->tc.tag = tag;
-- 
2.39.1


From 02d67c51765dfbd5893087da63744c864c7cc9e0 Mon Sep 17 00:00:00 2001
From: Arnaldo Carvalho de Melo <acme@redhat.com>
Date: Mon, 24 Oct 2022 11:25:44 -0300
Subject: [PATCH 29/29] pfunct: Use zalloc() to make the code more robust

Recently we had a problem where it was assumed that a field was
initialized to zeros but the constructor was using malloc(), check all
use and switch the ones allocating structs to zalloc() to prevent such
problems if we add extra fields to those structs.

Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
---
 pfunct.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/pfunct.c b/pfunct.c
index f42bdd1..5d34bc5 100644
--- a/pfunct.c
+++ b/pfunct.c
@@ -53,7 +53,7 @@ struct fn_stats {
 
 static struct fn_stats *fn_stats__new(struct tag *tag, const struct cu *cu)
 {
-	struct fn_stats *stats = malloc(sizeof(*stats));
+	struct fn_stats *stats = zalloc(sizeof(*stats));
 
 	if (stats != NULL) {
 		const struct function *fn = tag__function(tag);
-- 
2.39.1

